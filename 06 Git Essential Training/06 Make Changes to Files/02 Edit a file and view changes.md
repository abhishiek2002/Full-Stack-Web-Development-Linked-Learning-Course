Edit a file and view changes
- [Instructor] In the previous chapter, we added new files to our Git repository, both locally and remotely. But one of Git's best features is that it's able to track changes within files, not just add new ones. Committing changes to a file works almost exactly the same way as committing a new file. So let's walk through it. Here, I'll open up one of the files we've created earlier, Example.md. I'm going to make a small change. I'll add an extra line and I'll save. Now let's see how we can save this change in our Git history. I'll use the same process as before. First, I'll use git status to see that this file is modified but not staged at this point. Now I'll use git .add to stage all changes, and then git commit -m with a message. I'll press Enter and we have a new snapshot in our Git repository where I can now find the latest version of the file. But what if I want to see exactly what changed before I commit? Right now we're just working with singular files. It's easy to keep track. But in a large project, changes can add up quickly. Let's see how we can check what has been changed. I'll make another small change to my file, and I'll save that. Now I can use git diff. I'll clear it first, git diff. I can specify a file name or I can just press Enter to check all changes. As we can see, Git gives a clear overview of what's different. It marks lines that were removed and highlights new additions in green. For example, here it tells me that I've slightly modified a line by adding a hard return. This works across multiple files as well. So if I added Example02.md, let's say, I'll just add an explanation mark. I can now run git diff again. I'll clear the screen first, use git diff, and we can now some more information. You see a column at the end, which means that Git is not ready with giving you the information. If you press the Spacebar, it'll keep running. If you find yourself stuck with end in the end and you're not able to move on, just press Q and it'll bring you back to the prompt. Now let's look at those changes. I get an overview of all uncommitted changes, showing me everything that was modified, both in Example and Example02. Now, what if I've already added files to the staging area but still want to review those changes? That's where git diff --cached comes in. First, I'll add my files to the staging area with git add dot. I'll clear the screen, and now I'll use git diff --cached. When I press Enter, I get the same clear breakdown but now specifically for stage changes, everything that's about to be committed. Remember when you see the column, you can press space to see the rest, and when you going to go back to the prompt, you can press Q. And here I can see all the changes that are about to be committed. I am happy with these changes, so I will now use git commit -M adds extra lines to demonstrate git diff. There we go, and I'll push them to the remote repository. I can now see if it all works by using git status. And now we have changed our files. So whether you are working with a small or a large project, git diff is a great tool to help you keep track of what's changing before you commit, ensuring you always know exactly what's being saved in your repository.