Fetching data in React applications
- [Instructor] Whenever possible in a Next.js application, the best way to fetch data on the server is in a server component. So what this is going to mean for us is that we're going to fetch and render data in the same location. So what we can do here is we can go to our Mountain file. So the page file inside of Mountain is going to be the place where we can write an asynchronous function to get some data into the app. We're going to grab the response from await fetch. So fetch here, you might've seen fetch in other contexts. You might have seen it in the browser. You might have seen it in Node. There's all these different types of fetches that you can do to ask a REST API for some data and to get it back. So just for the sake of clarity here, I want to say that this fetch is a Next.js wrapper around fetch, but it does much the same thing. All I need to do here is pass in the API endpoint, which in this case is snowtooth-api-rest.fly.dev. So that's the location of this REST API. So what I'll do is return response.json and that will take whatever the response is here and turn it into a JSON string. So from here what I can do is fetch this data directly in the page. So we'll say const data = await getData. Then what I can do is make sure that my function here is asynchronous. So we could make the entire component that way, and then we can use that data somewhere within our component. So let's just add a div here. We're going to open and close a set of curly braces, and say JSON.stringify(data). So back to our browser, we should see, okay, we have all of this lift status information coming back, and that is good. We can see it. So let's go back here. We're going to take our div, and we're going to turn that into a table. Within the table, we're going to add a header, thead. Inside of this, we're going to add a row, and then inside of the row, we're going to add a th element that's going to be a table header. It'll have a little bit of bold style here, lift name, and current status. Okay, from here we'll add a table body, and the tbody, we should say data.data.allLifts.map. And here we're going to do the following. We'll say lift. This should return a table row with a key that says lift.id, and then we'll use this table data cell lift.name, and lift, td meaning a table cell lift.status. Okay, let's see how we're doing. So it looks like we're having trouble reading all undefined. So let's get rid of all lifts. Make sure we're parsing the data appropriately. A good way to really figure out what's going on here is we can say, let's go back to where we were before. JSON.stringify(data). Okay, so everything looks like it's at this main level, so I may not need all of that, so back to the drawing board. Let's get rid of those. We'll say data.map. Okay, there we go. Feeling good. Half the battle is making sure we're looking at the right key. So we've created this table. A server component is the best place to fetch data, because fetching data on the server will likely yield speedier results than fetching it on the client. So all of this can be handled by co-locating our data fetch with our component.