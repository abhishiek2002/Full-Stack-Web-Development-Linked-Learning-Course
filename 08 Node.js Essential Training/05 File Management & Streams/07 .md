Readable file streams
- [Instructor] Streams in Node.js give us a way to asynchronously handle continuous data flows. Understanding how streams work can dramatically improve the way your application handles large data. Streams are actually something we've already been using, so let's take a look at this ask.js file. Remember, this is where we took our questions and created an empty array of answers, and then we asked our users to type their answers into the chat. So process.standardoutput is what we've been using to write data to the terminal, but standard output is really a writeable stream. We send data chunks to it using the right method. Process.standardinput is a readable stream. Whenever a data event is raised like it is here, we're going to use a callback function and pass some data back into this callback function so that we can use it within the context of that function. So, we've been using streams already because process.standardinput and standard output implement the stream interface. Let's consider how working with file streams may allow us to improve our applications. We're going to open up this file called streams.js and we're going to import the file system module. Then we're going to call fs.readFile, and we're going to read from this file here. We have a directory called chat logs, and then in it, we have a chat. So let's go back to our streams here, and we're going to say ./chat-logs George Ben chat.log. We need to supply our UTF-8 character and coding format, and then the function that we'll pass here, error and chat log. Let's go ahead and start by reading the file length. So that should look like this, console.log file read chatLog.length. Now, after this, we'll say reading the file and let's make sure that we're in the right directory here. We're going to cd into 04 07 start, then we're going to node streams. This will read the file and it will work pretty fast, but the problem is that read file waits until the entire file is read before invoking the callback function. So before we make it to this function, we have to read the whole thing, and if we're reading a huge file, it's going to create some latency. So a better solution might be to use a readable stream. We'll do this here on line two. We'll say let stream equal fs.createReadStream. We'll pass in the same things except for our callback function here. I need to create a variable to hold onto this data, so we'll say let data. Now, instead of reading an entire file at once, a stream breaks the file down into bits or into different chunks. So, readable streams raise data events and pass small chunks of data to our callback. So we're not having to wait for an entire file before the first data chunk will log. We can use stream.once and we'll say on data. We will take a look at our function here, so we'll say, we'll use an arrow function and say console.log read stream started console.log, we'll add a line here with some equal signs, and then finally we'll say console.log chunk. So let's check this out. Read stream started and it's going to write everything here to our console. So the next thing we want to do is we want to call stream.on data. And here we'll also, we'll parse this chunk, and we'll say console.log chunk, chunk.length, display the character length of the data chunk, and then we're going to concatenate our data string with this text chunk. So we'll use data plus equals chunk. Finally, we'll add another one of these events, stream.on end. So when we're finished reading our chat log, the end event is going to be raised. So we'll say console.log finished data.length. Cool. So at this point, we should be able to run this node streams. So here we can see our different chunks. There's only one of these, but when it's over, we have a finished message. So stream.once is going to fire only once, it will log our read stream started and our equal sign divider here to our terminal, and it's also going to log all of the data. Now, when we call stream.on, it's going to break down everything into our different chunks. If I had a huge file, there might be a bunch of these different chunks. And finally, when we're finished, we're going to see that the data length is 115 characters. Using streams means that we don't have to wait for the entire file to finish loading before we start reading the data. Streaming video is a perfect example of this. When we watch a movie online, we can start watching it before the entire movie is fully downloaded. That's because we're breaking down our video into chunks that are streamed. So we can watch the first part of a movie while the rest of the movie is still being delivered.