Writable file streams
- [Instructor] In the last lesson, we introduced the Node.js stream interface and took a look at some readable streams. The other side of the stream coin is writeable streams. So the writeable stream is used to write the data chunks that are being read by the readable streams. So what we're going to do is improve our little ask questions app, and we'll do so first by importing, not surprisingly, our file system module. Let's also add a variable for the stream. We won't use it until our user answers the first question. So we'll say answerStream here, on line three. We'll keep our questions as is, we'll keep our empty array for our answers as is. Now, inside of our ask function, we can still use our process standard output. Let's create a once listener using process.stdin.once. We're going to listen for some data, and we'll pass that data to the callback function. So when the user answers the first question, what is your name, we're going to use that data to create a new markdown file. So here we'll say let name = data.toString.trim. So let's also refer to a file name, and we'll set that equal to whoever's name it is ./name.md. So if the file already exists, we'll find this out with existsSync fileName. If it already exists, we want to remove it and start fresh. So delete it with unlinkSync and the name of the file. Now what we can do inside of this is we can say, answerStream = fs.createWriteStream with the file name. So now we can use the file system to create a writeStream function. This is going to stream this new content to our new markdown file. So check this out. We'll say answerStream.write. And we'll say question answers for name, and then we'll add a new line character, we'll add a bunch of dividers, and then another new line character. Perfect. So now what we'll do, if we scroll down a little bit more, so we need to make some adjustments now to this onData function. So first we'll create a variable for our user's answer, so we'll say data.toString.trim. So let's pop that up here on line 31. Then we'll call answerStream.write, and when the user answers each question, we're going to write the question and the answer to the screen. We can use the answers array to identify which question was just asked. Then we'll call answerStream.write to grab the user's answer. So we'll just copy and paste this... And this time, we'll say answer. We'll add a function here. We're jumping out of the process when the time is right, when we're out of questions. Now, beneath this, we'll call answers.push and push in that answer. Now, the final thing we need to do here is, inside of our process on exit function, when the process exits, let's close our write stream using the close function. Now let's go ahead and try to run this again. We're going to make sure that we're in the right directory. We're going to node ask, what is your name. All right, and if we run this, it says question not defined. That is just a typo. The array is called questions, here on line 34. Let's try to run that again. Eve. What would you rather be doing? Skiing. What's your preferred programming language? You know it's JavaScript. Go skiing, Eve, so you can finish writing JavaScript later. I should also have, how cool is this, a new markdown file that's here in this directory with all of my questions and answers recorded. Working with streams is extremely important, because we're often dealing with a lot of data in our real world application, so I would highly recommend making use of these streams. You can create read streams and write streams to make your applications more performant.