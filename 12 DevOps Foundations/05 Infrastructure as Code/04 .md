Automating infrastructure, containers, and platforms
- Let's continue our survey of how DevOps has brought infrastructure-as-code to the domains of infrastructure provisioning, application deployment, and service orchestration. - The rise of cloud computing in the 2010s provided people with the ability to actually create servers, storage and network from code instead of just configuring the operating system on top of a manually installed device. - This made room for model driven provisioning, where a declarative model of your base systems can be used to create the systems. - [Presenter] Yeah, for example, Amazon Web Services has CloudFormation templates that you can use to define all kinds of cloud assets and then instantiate them automatically. Here you can see an example CloudFormation template indicating how it wants a server configured. You feed this into the cloud and it makes the server to the specification. - The appetite for even more sophisticated code solutions drove innovation. Custom infrastructure as code solutions like Terraform and Pulumi rose to dominance, providing an entire domain-specific language for infrastructure provisioning. Libraries to plug provisioning into common programming languages like Python's Bodo library and Amazon's CDK allow for pure play code solutions, at the risk of being a little less idempotent. - And now we're up to the late 2010s in the evolution of IaC tools and we have pretty decent solutions for provisioning and operating system configuration and okay solutions for deployment and orchestration, but the reasonable question arises, why would I use one model for my systems and another for my OS configuration and another for my applications? That seems pretty siloed and inefficient, right? Well, the rise of containers in the late 2010s accelerated this question. - [Presenter] In a container based architecture, Docker containers, for example, the server becomes less a part of the equation. Applications are packaged in one or more containers with just enough OS independencies to support them and then are deployed across a bare-bones physical infrastructure. - Yeah, developers loved having their own runtime bundled in with their application. It removes many sources of runtime bugs and allows for a very streamlined development and test cycle. - Giant cloud companies like Netflix had already begun to revert to the golden image model, creating entire cloud images with full application load-outs baked in, instead of trying to perform identical operations across thousands of servers with configuration management tools. - Yeah, they would build and deploy servers and intend for them not to change, to simply be destroyed and new ones get created as needed. This is called immutable infrastructure. You still may experience drift, but by design, you do not intend to change the infrastructure component once it's deployed. - [Presenter] Containers allow everyone to take the same approach. If you're deploying your application as one or more minimal containers, then rather than using runtime CM tools to change it in the production environment, you can just build a new complete container and immutably deploy it. It ends up being a lot simpler. - [Presenter] This has become very popular now in the 2020s. Container orchestration systems like Kubernetes and Mesos developed to try to solve all three challenges, provisioning, deployment, and orchestration in one package. Once you have the core platform working, you push application and infrastructure-as-code changes via templates and the system handles coordinating all those changes just automatically. - [Presenter] Serverless and other platform-as-a service offerings do the same, trying to reduce the problem to a simple transaction of you give me the new code and I'll just make it all happen and you don't have to worry about any of it. - I love not worried about any of it, but of course, that's not entirely true. Someone operating the platform still has to worry about it, - And that brings you up to date on the state of infrastructure-as-code in DevOps, the major approaches and how they're designed to work. - Yeah, we've mentioned a number of tools in context. Next, we'll dig into how to build out an infrastructure-as-code tool chain that you'll be proud to call your very own.