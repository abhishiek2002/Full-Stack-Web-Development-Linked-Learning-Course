Your DevOps infrastructure as code toolchain
- Now let's talk about choosing and using infrastructure as code tools. - Remember how we think about tools in DevOps. Pick the right tools for your team and situation. If nobody on your team knows a lick of programming, then probably choosing a tool that requires you to write Python is a stretch. - [Person In Brown Shirt] Yeah, and you want to keep it simple. You can always add more or more complex tools later on. - Finally, you're not just picking tools, you're creating a tool chain. One of the key benefits of infrastructure is code is that it encourages you to sit down and design out your operational environment before creating it like how any application should be built. Don't just grab tools and go. Plan out how you want this all to fit together. - Okay, here are the major decisions you'll want to make that will drive your tool choice. - Do you want to manage your own infrastructure or use a service where somebody else does it? If you're configuring your own bare metal, you could still use infrastructure as code. Digital Rebar is a great tool that automates the full stack of provisioning, from initial PXE booting, to BIOS and RAID configuration, to operating system and hypervisor installation. Then it integrates with higher level tools like Terraform to take you the rest of the way to working service. - Now, you need to provision your infrastructure. Do you want something that is template driven? Then you'd use Amazon's cloud formation or Azure ARM templates that lets you define your infrastructure in simple JSON or YAML format. - Do you want more power and want to specify all of these settings in a custom language with the idea that it'll work across multiple cloud providers? Tools like Terraform and Pulumi provide that. - [Person In Brown Shirt] Or do you want to drive it all out of pure code? In that case, Python's boto, Amazon's CDK and Azure's Bicep provide you libraries to plug into full programming languages. - They call it Bicep because it builds strong coding muscles! Flex with me, James. - No. Next you'll want to define how you plan to manage your systems. Are you going to use a Base OS image and a tool like Chef or Puppet, or CFengine to configure your servers at runtime? Or a tool like Ansible or Salt that also provides orchestration? - Or do you want to create custom images to use for these virtual servers? Hashicorp Packer is an example of an automated image building tool. This is often referred to as baking images. - Then you can immutably deploy your infrastructure just using virtual server images. Or you can create containers, which is the same concept, but you use Docker files to bake more fine grain container images. - You may not be picking just one, though. You might configure a base image with Chef and then bake it using Packer. You can chain together baking and configuring in a variety of different ways, depending on how you want to optimize your value stream. Baking moves time and risk earlier in the development cycle, while removing flexibility in production. - [Person In Brown Shirt] For orchestration, Do you want that as part of your CM tool, in which case you might want to use Ansible or Salt? - Or do you want it as a platform feature and you plan to use something like Kubernetes or Mesos? - [Person In Brown Shirt] Or, you can use an external runbook automation tool like Rundeck, or even custom code to coordinate runtime activities. - [Person In Red Shirt] How do you want to deploy your applications? Well, you can use one of those previous methods and use configuration management, or bake the app into a container system image and do immutable deployments. - Or you can leverage a continuous deployment system, many of which offer their own deployment methodology. - And finally, you want to figure out your testing strategy. I'll be frank: if you're not testing, you're not really coding. - Wait, I thought you were earnest. - In New York, I'm Frank, and in Chicago, I'm Earnest. - Many of these tools we've listed have existing test frameworks you can use to unit test your infrastructure code, and then to create it and integration test the infrastructure it produces. Learn them, love them, use them. - Here's an example tool chain I used at a previous job to run a major cybersecurity SaaS. We were completely Amazon Cloud-based. We used Terraform to build our base infrastructure, network, and core servers. Then we used Puppet to configure base images with our application on them, and baked them using Packer. We ran application upgrades using Rundeck as well. It did Terraform updates to update the infrastructure, and Puppet runs on the servers to update the applications. Puppet also ran in read-only mode on each server to provide drift detection. Every piece of this went through our continuous integration pipeline that did extensive testing of the app code, the infrastructure code, and the orchestration runbooks. This was pretty complicated, but it was necessary because of that product's need for customer isolation, data persistence, and customization. But then at the same place, we had a simpler security analysis and reporting system. There, I set up a base infrastructure using cloud formation, and then the app simply baked docker containers and deployed them to the Amazon managed container service, which handled orchestration itself. On our end, it was just a cloud formation template, docker files, and a build job. That system could tolerate immutable deployment, so we were able to run it with a lot less time, effort, and expense. - We hope that gives you an idea of how to create your own infrastructure as code tool chain.