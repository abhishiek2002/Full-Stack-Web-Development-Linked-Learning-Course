What is continuous delivery?
- There are three key stages in software development. The build where you compile and test code and turn it into software, the deploy where you take and run that software and test it, and the release where you send that software to an end user or, more usually nowadays, you deploy it in a production environment where someone else can use it - In the old way of delivering software, the whole application isn't built and run until major milestones are completed. Then there's a very large and complex integration build and a long test phase generating large batches of bug reports long after the code was first written. It's error prone and wasteful. - [Brown Shirt] So instead, what if you build, deploy, and release the application with every change a developer makes? - [Red Shirt] Continuous integration is the practice of automatically building and unit testing the entire application frequently, ideally on every source code check-in so that the application is always in a working state. - [Brown Shirt] Continuous delivery is the additional practice of deploying every change to a production-like test environment and performing automated integration and acceptance testing so that the application is always release ready. You'll hear people abbreviate the combination of both of these as CI/CD. - [Red Shirt] And then the real pro move, continuous deployment is the practice of releasing the application automatically into its production environment after the testing says it's ready to go. Large scale web properties, like Amazon, Meta, Google, and Wells Fargo, use continuous deployment. - Using these techniques decreases the time it takes to deploy a change and allows for rapid experimentation and market validation of ideas. - [Red Shirt] This is following the first way of DevOps, By optimizing end-to-end flow through the entire system and it lets you get a product to market faster. - [Brown Shirt] Yeah, organizations using continuous deployment might deploy a given application 10 times or more daily. But wait, isn't this reckless? You might think with rapid cycles and high frequency of change, you would see a decrease in quality. - But research consistently shows that these teams have a lower change failure rate than their peers. Moving faster means fewer bugs, not more. - This increase in quality happens because instead of checking that everything works only at the end of the development cycle, we're testing earlier in the process. Instead of one huge release consisting of hundreds of changes, we evaluate and deploy changes one by one, testing every commit and making sure the software is always in a running state. - [Red Shirt] If you've been paying attention, you may be shouting "Second way" at your screen and alarming your coworkers, family or pets, and you'd be right. CI leverages the ability to make fast feedback loops, which lets you find and fix issues quickly and drives up your quality while you also drive up your velocity. And then you can safely get those changes all the way out to production as soon as possible. - Lean teaches us that a high level of work in progress, abbreviated WIP, is dangerous. Code that's sitting around in your system undelivered, it's generating risk and waste. - At a large enterprise where we once worked, we performed these monthly releases to a large e-commerce site that would start on a Friday evening and take eight hours, manually releasing 30 or so applications into an environment that had a hundred apps in it. Nothing about that was good. People had to wait for a monthly release so they'd panic and cut corners if they were going to miss it. The release itself was painful and error-prone, and when inevitably something went wrong, you had 30 developers pointing fingers at each other sure that someone else was causing the site to go down. - The State of DevOps Report found that high performers reported that their lead time required to deploy changes into production was less than one hour, whereas low performers required lead times between one to six months. - That's a huge competitive advantage, but the benefits extend past the development cycle. There are two advantages to a continuous delivery environment that make your mean time to recover from production problems shorter too. - The first benefit is that using continuous delivery makes it easier to find the source of failures because, hey, you're only rolling out one change at a time. - Then when you do find a problem, a bug fix can be treated just like any other change and rolled out quickly via continuous integration and delivery without breaking your process. - Okay, for example, I once had an app that exhibited a slow leak of database connections over time. It grew and grew over a few days until it hit its limit and everything broke. This type of slow leak over time problem can sometimes consume a lot of resources trying to find out why this is happening. But since we practiced all the things that we've talked about here, like small and frequent deploys, we had an advantage. By overlaying our database connection growth graph with the deploys that happened that week, we could quickly figure out precisely which production deployment correlated with the increase of database connections. Once we had the deployment ID, we could determine which exact code commit introduced the leak and we rolled out a fix within hours using our normal CI/CD system. - [Red Shirt] That's cool. Next, we'll talk about how to implement continuous integration in a build pipeline.