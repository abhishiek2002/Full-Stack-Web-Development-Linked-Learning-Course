The role of QA in DevOps
- Continuous delivery sounds too good to be true, James. Faster deploys, fewer bugs, less whip, less technical debt, developers and operations living together. What's the catch? - Well, you got me. There is a catch. All of this is a non-starter unless you address testing and the role of quality assurance in your pipeline. - That's right. Moving to automated testing as part of your pipeline is the only way to get CI and CD without massive problems. You can't deliver value or find issues quickly if you're not testing in each phase of your pipeline. And manual testing is slow and unreliable and it's best used only for final acceptance testing. Maybe. - That's not to say you don't need people experienced in QA. You just want them helping to design and write tests and working alongside the developers as part of the process. Let the computers do the clicking. - That's right. Let's talk about the types of testing to pay attention to in continuous delivery. - We'll start with the most developer-centric testing methodologies and gradually work our way to testing that occurs near the end of our pipelines. - [Instructor] Or, if you're familiar with Mike Cohn's test pyramid, we'll be working from the bottom up, starting with the fastest, more code focused testing and moving to slower, full end-to-end testing. First is unit testing. These are tests written by the developer as part of the code to validate that individual functions work correctly. Let's say you have a calculator application with a function called add that takes two numbers and adds 'em together. - In unit testing, we would write a test inside the code base to validate that function. This is usually the fastest testing available. You write code to skip over or stub out external dependencies. Unit tests are run by the developer, on their own machine, as they write code. - Next up, code hygiene. - Okay, is this like flossing your teeth but for code? - Yes, but you should actually do it. - Okay, yeah. Code hygiene testing checks your code for best practices for your particular language or framework. It's usually accomplished through tools called linters or formatters, and you got to keep up the code hygiene. You don't want to end up at the DevOps dentist. - My mama said, "Son, be a dentist. You'll be a success." - Okay. Onto integration testing. It's performed with all the apps, components and dependencies operating in a test environment, and tests are written to make sure the components work well, both individually and together. - And then you have acceptance or end-to-end testing, often done at a UI level, that tests the entire end product as an end user would experience it. All of these can and should be automated. A manual check before you unleash a new feature on your users is still fine, but let the computers do the thousands of combinations you need to do good testing. - That's a lot of kinds of testing to automate. How do we set up a culture and process that encourages us to actually write them? This is where a test driven development and behavior driven development comes in. - [Instructor] TDD and BDD are development practices that start with writing tests or checking for desired behaviors before you write the code that it tests. - [James] Yeah. With this approach, the flow of our calculator example would be that you write the desired output of the ad function and then that test starts failing because there's nothing there to make it work yet. Then you write the function and once you get it right, the test starts passing. - Now you're creating a comprehensive test suite while the application is being developed. - Okay, so far all the testing we've talked about has been reasonably fast, so you can put it into your build pipeline and still have good build times. But what about slower types of tests that have to run for a long time, like browser compatibility test or large compliance test suites? - Slow tests can't be ignored if there's no practical way to speed them up. - Yeah. To get around this, there's three strategies to use. Run slow tests in parallel in your pipeline, not blocking until the end release. Use scheduled testing like a nightly test suite and run slow test suites continuously against your test environment. It can be okay to release a non-critical bug and then find it overnight. In a CD world, you can fix it very quickly. Does every release need to wait on that test to make sure it works perfectly in super old browsers? Balance the cost of delay versus the cost of bugs. - There are many other specialty tests you'll need. Infrastructure testing, performance testing, and security testing to name a few. - Yeah, testing is a huge domain, but getting good at automated testing is your single most significant factor in successful continuous delivery. If you embrace it and stick with it, you'll be moving faster than those that don't.