Continuous deployment: The final frontier
- Now that you're doing Continuous Delivery, what about Continuous Deployment? Push that change all the way live as soon as it passes testing? - Now, some organizations don't feel comfortable with it, and that's okay. You may need a manual test cycle. You may want some product manager or someone to do a final sign off on a release. You may want to bundle up changes, so that users can consume them as a batch, instead of small changes all the time. - But if you're doing good CI and CD, you should be ready to do it safely. Approvals and testing can happen as part of the pipeline, even as manual workflow steps, just like code reviews, and if you use future flags, you can have batches of new code already deployed to production before you let users see it. - That's right. In the immortal words of Suga Free, "If you stay ready, you ain't got to get ready." - Let's look at the release stage of our pipeline. Once it passes all your tests, the artifact is released. This means market it in some way, as having been released to production at a given time. Then when you want, you deploy the artifacts to your production environment and trigger notifications for compliance and internal and end user communication. So is this just Continuous Delivery done a second time? - Well, yes and no. No, because production releases often require significant engineering work to safely automate. If you're releasing packaged software, you only have to worry about data and configuration working right with a new version. But if you release a running service, you have live users and flowing data to contend with. But also, yes, because whatever complex release procedure you create, you have to go back and implement that same thing in your test environment, or else you've introduced a unique and not continually tested part of your system. If you do that, it's bad and you should feel bad. - Wow, Ernest, you're being rather opinionated today. But maybe that's because when you implement Continuous Deployment, you need it to be an opinionated system. In other words, there should be one right way to do it that the system makes very easy. - There are many different Production Release Patterns you can use depending on your specific needs. In general, you want them to be safe, reversible, and to provide no downtime to active users. - [Host] Some patterns you might see are a Rolling Deployment. In other words, upgrading one of many identical systems at a time, to allow seamless shifting of traffic. - [Ernest] A Blue-Green Deployment, where you create an entire new version of the system and then cut user traffic over from the current or Blue System to the new or Green System. This could be swapping persistent test and production environments or making a new one from scratch in the Cloud. - [Host] A Canary Deployment, where you only upgrade one of many identical systems and let it run for a while, to see if it exhibits any problems under production load. - [Ernest] An A/B Deployment, where you release feature flagged software, and then use a system to open up the new features only to a certain subset of users, either briefly as a Canary Test, or longer for a Public Beta Test. - [Host] How you can perform a Production Deployment is very dependent on your packaging choice, infrastructure as code strategy, and the software architecture of your service. - You have to design your deployment in collaboration with the people designing those other parts. - You're right, Ernest. I built out Continuous Deployment for Signal Sciences, a security startup that started with a small team of five, but quickly grew to over 100. At that time, there wasn't much tooling out there, so we wrote an internal tool called Deployer, based off of Etsy's similar Deployinator Tool. Once we had Continuous Integration and Continuous Delivery in place, anyone in the company could go to Deployer and deploy the latest build to staging, and if it passed automated testing and it did what the developer expected, then it was eligible to deploy to production. Now, it didn't happen automatically, but it literally was a push of a button. We followed one of the mantras we talked about earlier. From code commit to running in production, it took five minutes or less. We used a Rolling Deployment Pattern, along with the A/B Deployment Pattern, using feature flags. Developers would often release features to internal users, early adopters, and then all the customers over a few weeks to make sure the usage was what we expected and that the new features were delightful to customers. Funny enough, Deployer even had a mode where it would deploy itself. This made our entire pipeline something that any engineer could make changes to and deploy, via self-service automation. - That's awesome, deployment is the first place the DEV and OPs worlds collide, whether they want to or not, and can make for a great end user experience or a terrible one.