Your DevOps CI toolchain
- When selecting tools for CI toolchains, it's tempting to start from the developer and work your way out to the delivered service or software. - In fact, people often refer to a continuous delivery toolchain as a pipeline, because code flows in one end and finished product out the other. That makes sense, but for your continuous delivery toolchain, we're going to encourage you to approach it a little differently, - And it takes different strokes to move the world. - [James] Instead of a left-to-right flow, think of these as layers to an onion. We're going to start at the outer layer and work our way in, because we want to consider the entire toolchain from the perspective of what we want the end state to be. - The outermost layer of the onion is deployment. What does the system you're building look like, and how do you want it to operate? First, how's the software going to be deployed and used by the end user, containers, system images, Windows installers? - [James] Yeah, when you consider deployments, you'll need to consider what type of tooling you'll want in place. Are you doing A/B deploys? If so, you'll need to use feature flagging. You can use commercial tools like LaunchDarkly or Split or even write your own feature flagging in your code. - If you decided on rolling deploys, you'll need orchestration for rolling out releases across your fleet, and this will depend on your infrastructure tooling. For example, if you're using Kubernetes or Serverless, they'll have options built into their platform. Otherwise, you might use deployment orchestration built in Ansible or Salt. These decisions affect your runtime system, and therefore cascade all the way back to the front end of your pipeline, driving tool choices at those other stages. - Okay, now if we move one layer in, we have the artifact repository. General solutions like Artifactory or Nexus manage lots of different artifact formats, from operating system packages to Java archives to containers. - There are also many point solutions that just handle one type of artifact. For example, most cloud providers offer private container repositories, and there's software and services to set up programming language-specific artifact repos, for example, bit.dev for private NPM repositories. - Ernest, you know, one option I've used before is just to have the build system tag and zip the artifact and upload it to Amazon S3. Now that's a minimum viable artifact repository. - That'll work. - Okay, well now, let's move one more layer in. The artifact had to come from somewhere, as it had to be built and pass tests. - We could go through a massive list here of all the testing tools you'd need, but no matter how thorough we are, we'd never enumerate all of the tools available. - Instead, let's cover the categories, and we'll just mention a few testing tools we've used before. That should be enough to prime you for searching for a similar tool that works for your purpose. - Unit testing runs all the code-specific unit tests that your dev team wrote. Most languages will have a built-in way to do unit tests. For example, Golang has go test. - Code hygiene and linters enforce code standards and quality across the team. In JavaScript, you could use ESLint, or in Golang, there's staticcheck. - Integration testing ensures your proposed artifact works with the rest of the system, including other APIs and data storage services. Pytest is one framework for Python. TestNG is one for Java. - And finally, acceptance, or end-to-end testing, is often UI-based, and you can use tools like Selenium or cypress.io. Complex apps without a UI can be tested under other automation tools, like Robot Framework or Postman. - [Instructor] Depending on your application or system, you'll likely need infrastructure testing, performance testing, and security testing, too. - [James] Oh yeah, most IAC frameworks have a test solution built in, often variations on RSpec, like InSpec or ChefSpec. - For performance testing. Java's JMeter is popular, and there are also many commercial tools, like LoadRunner. - For security, GitHub Dependabot and GitGuardian are both easy to integrate in a GitHub-based pipeline. My own company, Dryrun Security, provides security analysis and pull requests before they ever enter CI/CD, and other tools, like StackHawk, do dynamic scans inside of GitHub Actions. There are a lot of options here. - [Instructor] The next layer is the build system. This is what actually performs the build work and initiates the later stages in the pipeline. - Jenkins is open source, and is popular in many organizations. Its UI is a bit difficult to navigate at times, but it has tons of community support, and almost every provider integrates with it. - [Instructor] Or you might be inclined to use SaaS-based offerings for CI, like CloudBees and CircleCI. - GitHub even offers build pipelines built into their version control system nowadays, called GitHub Actions. It's popular for its simplicity. - And that leads us to the very middle of the onion, version control. - Ah, don't make me cry. - [Instructor] (sighs) Version control is where we commit code changes and view the entire history of all changes ever made. It allows the developers to stay in sync with each other by treating each change as an independent layer. - [James] Most organizations today opt to use Git in the form of GitHub, GitLab, or Bitbucket, either as a SaaS or as an on-prem enterprise version. - But there are other specialized version control systems, like Perforce and PlasticSCM if you need to manage very large binary assets in source control. Once you've planned out your CD pipeline, trace a single code change through it and measure how fast it moves from a developer system to production. This is your overall cycle time. - That's right. Record it, log it, graph it, and actively share this number with the team. Over time, it will get worse if you don't actively work to make it better. What better looks like for your team depends on your toolchain, but try to make choices that lower overall cycle time, not increase it. - And that's your CI toolchain in a nutshell. - Or in an onion skin. (instructor sighs) - Links to all the tools we've mentioned and more are in the course handout in the example files.